package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/constant"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/scylladb/go-set/strset"
	"golang.org/x/tools/go/packages"
)

var funcMap = template.FuncMap{
	"join": strings.Join,
}

type GeneratorOptions struct {
	Args         []string
	BuildTags    string
	GenerateFlag bool
	Output       string
	Type         string
}

type Generator struct {
	generateIDs    bool
	options        GeneratorOptions
	pkgDefs        map[*ast.Ident]types.Object
	pkgName        string
	underlyingType string
	values         []Value
}

type Value struct {
	ID           string
	Name         string
	OriginalName string
	Value        string
}

func NewGenerator(options GeneratorOptions) *Generator {
	return &Generator{options: options}
}

func (g *Generator) Run() ([]byte, error) {
	var (
		tags   []string
		output string
	)

	if g.options.BuildTags != "" {
		tags = strings.Split(g.options.BuildTags, ",")
	}

	if g.options.Output == "" {
		output = "."
	}

	cfg := &packages.Config{
		Mode:       packages.LoadSyntax,
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}

	pkgs, err := packages.Load(cfg, g.options.Output)
	if err != nil {
		return nil, err
	}

	if len(pkgs) != 1 {
		return nil, fmt.Errorf("%d packages found", len(pkgs))
	}

	g.pkgName = pkgs[0].Name
	g.pkgDefs = pkgs[0].TypesInfo.Defs

	pkgFiles := pkgs[0].Syntax

	for _, file := range pkgFiles {
		ast.Inspect(file, g.findType)
	}

	data := struct {
		Args           []string
		GenerateFlag   bool
		GenerateIDs    bool
		PackageName    string
		Type           string
		UnderlyingType string
		Values         []Value
	}{
		Args:           g.options.Args,
		GenerateFlag:   g.options.GenerateFlag,
		GenerateIDs:    g.generateIDs,
		PackageName:    g.pkgName,
		Type:           g.options.Type,
		UnderlyingType: g.underlyingType,
		Values:         g.values,
	}

	var buf bytes.Buffer

	if err := _tmpl.Execute(&buf, data); err != nil {
		return buf.Bytes(), err
	}

	output = filepath.Join(output, fmt.Sprintf("%s_enum.go", strings.ToLower(g.options.Type)))

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), err
	}

	if err := os.WriteFile(output, src, 0o644); err != nil {
		return buf.Bytes(), err
	}

	return src, nil
}

func (g *Generator) findType(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.CONST {
		// Enum declarations need to be const.
		return true
	}

	typ := "" // name of the constant

	for _, spec := range decl.Specs {
		vspec := spec.(*ast.ValueSpec) // we've already determined this is a const
		if vspec.Type != nil {
			ident, ok := vspec.Type.(*ast.Ident)
			if !ok {
				continue
			}

			typ = ident.Name
		}

		if g.options.Type != typ {
			// Not the type we want.
			continue
		}

		for _, name := range vspec.Names {
			if name.Name == "_" {
				continue // ignore
			}

			obj, ok := g.pkgDefs[name]
			if !ok {
				log.Fatalf("no value for constant %q", typ)
			}

			info := obj.Type().Underlying().(*types.Basic)
			switch info.Kind() {
			case types.Int:
			case types.Int8:
			case types.Int16:
			case types.Int32:
			case types.Int64:
			case types.Uint:
			case types.Uint8:
			case types.Uint16:
			case types.Uint32:
			case types.Uint64:
			default:
				log.Fatalf("%q must be an integer type", typ)
			}

			g.underlyingType = info.String()

			value := obj.(*types.Const).Val()
			if value.Kind() != constant.Int {
				log.Fatalf("%q constant is not an integer", name)
			}

			v := Value{
				OriginalName: name.Name,
				Value:        value.ExactString(),
			}

			comment := vspec.Comment
			if comment != nil && len(comment.List) == 1 {
				text := strings.ReplaceAll(strings.TrimSpace(comment.Text()), " ", "")
				fields := strset.New(strings.Split(text, ",")...)

				hasName := fields.Has("name")

				fields.Each(func(field string) bool {
					idx := strings.LastIndex(field, "=")

					if hasName && field == "name" {
						v.Name = field[idx+1:]
					}

					if strings.Contains(field, "id") {
						v.ID = field[idx+1:]
						g.generateIDs = true
					}

					return true
				})
			} else {
				v.Name = strings.ToLower(strings.TrimSpace(name.Name))
				v.Name = strings.ReplaceAll(v.Name, "_", "-")
			}

			g.values = append(g.values, v)
		}
	}

	return false
}

var _tmpl = template.Must(template.New("").Funcs(funcMap).Parse(`// Code generated by "gen-enum {{ join .Args " " }}"; DO NOT EDIT.
package {{ .PackageName }}

import "errors"

func _() {
	// An "invalid array index" compiler error signifies that the constant
	// values have changed. Run the generator again.
	var x [1]struct{}
        {{- range $i, $value := .Values }}
	_ = x[{{ $value.OriginalName }}-{{ $i }}]
        {{- end }}
}

var _{{ .Type }}_string_to_type = map[string]{{ .Type }}{
	{{- range $i, $value := .Values }}
	"{{ $value.Name }}": {{ $value.OriginalName }},
	{{- end }}
}

var _{{ .Type }}_type_to_string = map[{{ .Type }}]string{
	{{- range $i, $value := .Values }}
	{{ $value.OriginalName }}: "{{ $value.Name }}",
	{{- end }}
}

{{ if .GenerateIDs }}
var _{{ .Type }}_id_to_type = map[{{ .UnderlyingType }}]{{ .Type }}{
	{{- range $i, $value := .Values }}
	{{ $value.ID }}: {{ $value.OriginalName }},
	{{- end }}
}

var _{{ .Type }}_type_to_id = map[{{ .Type }}]{{ .UnderlyingType }}{
	{{- range $i, $value := .Values }}
	{{ $value.OriginalName }}: {{ $value.ID }},
	{{- end }}
}
{{ end }}

var ErrInvalid{{ .Type }} = errors.New("invalid {{ .Type }}")

{{ if .GenerateIDs }}
func (i *{{ .Type }}) ID() {{ .UnderlyingType }} {
	return _{{ .Type }}_type_to_id[*i]
}
{{ end }}

func (i *{{ .Type }}) String() string {
	return _{{ .Type }}_type_to_string[*i]
}

{{ if .GenerateFlag }}
func (i *{{ .Type }}) Set(s string) error {
	if t, ok := _{{ .Type }}_string_to_type[s]; ok {
		*i = t
		return nil
	}
	return ErrInvalid{{ .Type }}
}

func (i *{{ .Type }}) Type() string {
	return i.String()
}
{{ end }}

{{ if .GenerateIDs }}
func IDTo{{ .Type }}(i {{ .UnderlyingType }}) *{{ .Type }} {
	if t, ok := _{{ .Type }}_id_to_type[i]; ok {
		return &t
	}
	return nil
}
{{ end }}

func StringTo{{ .Type }}(s string) *{{ .Type }} {
	if t, ok := _{{ .Type }}_string_to_type[s]; ok {
		return &t
	}
	return nil
}

func Is{{ .Type }}(s string) bool {
	if _, ok := _{{ .Type }}_string_to_type[s]; ok {
		return true
	}
	return false
}

func {{ .Type }}List() []{{ .Type }} {
	return []{{ .Type }}{
		{{- range $i, $value := .Values }}
		{{ $value.OriginalName }},
		{{- end }}
	}
}
`))
